#
# Targets "primary" and "clipboard" clipboards if using xclip, see:
# http://unix.stackexchange.com/a/69134/89254
X11_write_clip <- function(content, object_type, breaks, eos, return_new, ...) {
if (has_xclip()) {
con <- pipe("xclip -i -sel p -f | xclip -i -sel c", "w")
} else if (has_xsel()) {
con <- pipe("xsel --clipboard --input", "w")
} else {
notify_no_cb()
}
.dots <- list(...)
write_nix(content, object_type, breaks, eos, return_new, con, .dots)
}
write_clip_tibble_with_header(airports)
write_clip_tibble_with_header = function(tbl){
object_type = "character"
envir_vars = Sys.getenv()
header_content = paste0(
"User: ",envir_vars["USERNAME"]," Timestamp: ",Sys.time(),
" Clipped From: ", rstudioapi::getSourceEditorContext()$path
)
line_tbl = tbl %>%
tidyr::unite(line,everything(),sep = "\t")
string_tbl = line_tbl %>%
dplyr::summarise(all_lines = paste(line,collapse = "\n")) %>%
pull(all_lines)
out_tbl = paste0(header_content,"\n\n",string_tbl)
sys.type <- Sys.info()["sysname"]
chosen_write_clip <- switch(sys.type, Darwin = osx_write_clip,
Windows = win_write_clip, X11_write_clip)
invisible(chosen_write_clip(out_tbl, object_type, breaks,
eos, return_new, ...))
}
# Helper function to write to the Windows clipboard
win_write_clip <- function(content, object_type, breaks, eos, return_new, ...) {
.dots <- list(...)
# If no custom line separator has been specified, use Windows's default
# newline character '\r\n'
breaks <- ifelse(is.null(breaks), '\r\n', breaks)
# If no custom tab separator for tables has been specified, use Windows's
# default tab character: '\t'
.dots$sep <- ifelse(is.null(.dots$sep), '\t', .dots$sep)
# Pass the object to rendering functions before writing out to the clipboard
rendered_content <- render_object(content, object_type, breaks, .dots)
utils::writeClipboard(rendered_content, format = 1)
if (return_new) {
rendered_content
} else {
content
}
}
# Helper function to write to the OS X clipboard
# Adapted from https://github.com/jennybc/reprex/blob/master/R/clipboard.R
osx_write_clip <- function(content, object_type, breaks, eos, return_new, ...) {
.dots <- list(...)
con <- pipe("pbcopy")
write_nix(content, object_type, breaks, eos, return_new, con, .dots)
}
# The same content rendering and writing steps are used in both OS X and Linux,
# just with different connection objects
write_nix <- function(content, object_type, breaks, eos, return_new, con, .dots) {
# If no custom line separator has been specified, use Unix's default newline
# character '\n'
breaks <- ifelse(is.null(breaks), '\n', breaks)
# If no custom tab separator for tables has been specified, use Unix's default
# tab character: '\t'
.dots$sep <- ifelse(is.null(.dots$sep), '\t', .dots$sep)
# Pass the object to rendering functions before writing out to the clipboard
rendered_content <- render_object(content, object_type, breaks, .dots)
# Suppress pipe() warning when writing an empty string with a NULL string
# ending.
if (identical(rendered_content, "")) {
suppressWarnings(writeChar(rendered_content, con = con, eos = eos))
} else {
writeChar(rendered_content, con = con, eos = eos)
}
close(con)
if (return_new) {
rendered_content
} else {
content
}
}
# Helper function to write to the X11 clipboard
#
# Requires the utility 'xclip' or 'xsel'. This function will stop with an error
# if neither is found. Adapted from
# https://github.com/mrdwab/overflow-mrdwab/blob/master/R/writeClip.R
#
# Targets "primary" and "clipboard" clipboards if using xclip, see:
# http://unix.stackexchange.com/a/69134/89254
X11_write_clip <- function(content, object_type, breaks, eos, return_new, ...) {
if (has_xclip()) {
con <- pipe("xclip -i -sel p -f | xclip -i -sel c", "w")
} else if (has_xsel()) {
con <- pipe("xsel --clipboard --input", "w")
} else {
notify_no_cb()
}
.dots <- list(...)
write_nix(content, object_type, breaks, eos, return_new, con, .dots)
}
write_clip_tibble_with_header(airports)
# Helper function to write to the Windows clipboard
win_write_clip <- function(content, object_type, breaks, eos, return_new, ...) {
.dots <- list(...)
# If no custom line separator has been specified, use Windows's default
# newline character '\r\n'
breaks <- ifelse(is.null(breaks), '\r\n', breaks)
# If no custom tab separator for tables has been specified, use Windows's
# default tab character: '\t'
.dots$sep <- ifelse(is.null(.dots$sep), '\t', .dots$sep)
# Pass the object to rendering functions before writing out to the clipboard
rendered_content <- render_object(content, object_type, breaks, .dots)
utils::writeClipboard(rendered_content, format = 1)
if (return_new) {
rendered_content
} else {
content
}
}
# Helper function to write to the OS X clipboard
# Adapted from https://github.com/jennybc/reprex/blob/master/R/clipboard.R
osx_write_clip <- function(content, object_type, breaks, eos, return_new, ...) {
.dots <- list(...)
con <- pipe("pbcopy")
write_nix(content, object_type, breaks, eos, return_new, con, .dots)
}
# The same content rendering and writing steps are used in both OS X and Linux,
# just with different connection objects
write_nix <- function(content, object_type, breaks, eos, return_new, con, .dots) {
# If no custom line separator has been specified, use Unix's default newline
# character '\n'
breaks <- ifelse(is.null(breaks), '\n', breaks)
# If no custom tab separator for tables has been specified, use Unix's default
# tab character: '\t'
.dots$sep <- ifelse(is.null(.dots$sep), '\t', .dots$sep)
# Pass the object to rendering functions before writing out to the clipboard
rendered_content <- render_object(content, object_type, breaks, .dots)
# Suppress pipe() warning when writing an empty string with a NULL string
# ending.
if (identical(rendered_content, "")) {
suppressWarnings(writeChar(rendered_content, con = con, eos = eos))
} else {
writeChar(rendered_content, con = con, eos = eos)
}
close(con)
if (return_new) {
rendered_content
} else {
content
}
}
# Helper function to write to the X11 clipboard
#
# Requires the utility 'xclip' or 'xsel'. This function will stop with an error
# if neither is found. Adapted from
# https://github.com/mrdwab/overflow-mrdwab/blob/master/R/writeClip.R
#
# Targets "primary" and "clipboard" clipboards if using xclip, see:
# http://unix.stackexchange.com/a/69134/89254
X11_write_clip <- function(content, object_type, breaks, eos, return_new, ...) {
if (has_xclip()) {
con <- pipe("xclip -i -sel p -f | xclip -i -sel c", "w")
} else if (has_xsel()) {
con <- pipe("xsel --clipboard --input", "w")
} else {
notify_no_cb()
}
.dots <- list(...)
write_nix(content, object_type, breaks, eos, return_new, con, .dots)
}
write_clip_tibble_with_header(airports)
write_clip_tibble_with_header = function(tbl){
object_type = "character"
envir_vars = Sys.getenv()
header_content = paste0(
"User: ",envir_vars["USERNAME"]," Timestamp: ",Sys.time(),
" Clipped From: ", rstudioapi::getSourceEditorContext()$path
)
line_tbl = tbl %>%
tidyr::unite(line,everything(),sep = "\t")
string_tbl = line_tbl %>%
dplyr::summarise(all_lines = paste(line,collapse = "\n")) %>%
pull(all_lines)
out_tbl = paste0(header_content,"\n\n",string_tbl)
sys.type <- Sys.info()["sysname"]
chosen_write_clip <- switch(sys.type, Darwin = osx_write_clip,
Windows = win_write_clip, X11_write_clip)
invisible(chosen_write_clip(out_tbl, object_type, breaks,
eos, return_new, ...))
}
write_clip_tibble_with_header(airports)
write_clip_tibble_with_header = function(tbl, ...){
object_type = "character"
envir_vars = Sys.getenv()
header_content = paste0(
"User: ",envir_vars["USERNAME"]," Timestamp: ",Sys.time(),
" Clipped From: ", rstudioapi::getSourceEditorContext()$path
)
line_tbl = tbl %>%
tidyr::unite(line,everything(),sep = "\t")
string_tbl = line_tbl %>%
dplyr::summarise(all_lines = paste(line,collapse = "\n")) %>%
pull(all_lines)
out_tbl = paste0(header_content,"\n\n",string_tbl)
sys.type <- Sys.info()["sysname"]
chosen_write_clip <- switch(sys.type, Darwin = osx_write_clip,
Windows = win_write_clip, X11_write_clip)
invisible(chosen_write_clip(out_tbl, object_type, breaks,
eos, return_new, ...))
}
write_clip_tibble_with_header(airports)
write_clip_tibble_with_header = function(tbl, ...){
object_type = "character"
breaks = NULL
eos = NULL
return_new = FALSE
envir_vars = Sys.getenv()
header_content = paste0(
"User: ",envir_vars["USERNAME"]," Timestamp: ",Sys.time(),
" Clipped From: ", rstudioapi::getSourceEditorContext()$path
)
line_tbl = tbl %>%
tidyr::unite(line,everything(),sep = "\t")
string_tbl = line_tbl %>%
dplyr::summarise(all_lines = paste(line,collapse = "\n")) %>%
pull(all_lines)
out_tbl = paste0(header_content,"\n\n",string_tbl)
sys.type <- Sys.info()["sysname"]
chosen_write_clip <- switch(sys.type, Darwin = osx_write_clip,
Windows = win_write_clip, X11_write_clip)
invisible(chosen_write_clip(out_tbl, object_type, breaks,
eos, return_new, ...))
}
write_clip_tibble_with_header(airports)
# Check object type to determine if it will be handled as a simple table or as a
# character vector
render_object <- function(content, object_type, breaks, .dots) {
if (object_type == "auto")
object_type <- eval_object(content)
switch(object_type,
"table" = table_str(content, breaks, .dots),
"character" = flat_str(content, breaks))
}
write_clip_tibble_with_header(airports)
write_clip_tibble_with_header = function(tbl, ...){
object_type = "character"
breaks = NULL
eos = NULL
return_new = FALSE
envir_vars = Sys.getenv()
header_content = paste0(
"User: ",envir_vars["USERNAME"]," Timestamp: ",Sys.time(),
" Clipped From: ", rstudioapi::getSourceEditorContext()$path
)
line_tbl = tbl %>%
tidyr::unite(line,everything(),sep = "\t")
string_tbl = line_tbl %>%
dplyr::summarise(all_lines = paste(line,collapse = "\n")) %>%
pull(all_lines)
out_tbl = paste0(header_content,"\n\n",string_tbl)
sys.type <- Sys.info()["sysname"]
chosen_write_clip <- switch(sys.type, Darwin = osx_write_clip,
Windows = win_write_clip, X11_write_clip)
invisible(chosen_write_clip(out_tbl, object_type, breaks,
eos, return_new, ...))
}
# Helper function to write to the Windows clipboard
win_write_clip <- function(content, object_type, breaks, eos, return_new, ...) {
.dots <- list(...)
# If no custom line separator has been specified, use Windows's default
# newline character '\r\n'
breaks <- ifelse(is.null(breaks), '\r\n', breaks)
# If no custom tab separator for tables has been specified, use Windows's
# default tab character: '\t'
.dots$sep <- ifelse(is.null(.dots$sep), '\t', .dots$sep)
# Pass the object to rendering functions before writing out to the clipboard
rendered_content <- render_object(content, object_type, breaks, .dots)
utils::writeClipboard(rendered_content, format = 1)
if (return_new) {
rendered_content
} else {
content
}
}
# Helper function to write to the OS X clipboard
# Adapted from https://github.com/jennybc/reprex/blob/master/R/clipboard.R
osx_write_clip <- function(content, object_type, breaks, eos, return_new, ...) {
.dots <- list(...)
con <- pipe("pbcopy")
write_nix(content, object_type, breaks, eos, return_new, con, .dots)
}
# The same content rendering and writing steps are used in both OS X and Linux,
# just with different connection objects
write_nix <- function(content, object_type, breaks, eos, return_new, con, .dots) {
# If no custom line separator has been specified, use Unix's default newline
# character '\n'
breaks <- ifelse(is.null(breaks), '\n', breaks)
# If no custom tab separator for tables has been specified, use Unix's default
# tab character: '\t'
.dots$sep <- ifelse(is.null(.dots$sep), '\t', .dots$sep)
# Pass the object to rendering functions before writing out to the clipboard
rendered_content <- render_object(content, object_type, breaks, .dots)
# Suppress pipe() warning when writing an empty string with a NULL string
# ending.
if (identical(rendered_content, "")) {
suppressWarnings(writeChar(rendered_content, con = con, eos = eos))
} else {
writeChar(rendered_content, con = con, eos = eos)
}
close(con)
if (return_new) {
rendered_content
} else {
content
}
}
# Helper function to write to the X11 clipboard
#
# Requires the utility 'xclip' or 'xsel'. This function will stop with an error
# if neither is found. Adapted from
# https://github.com/mrdwab/overflow-mrdwab/blob/master/R/writeClip.R
#
# Targets "primary" and "clipboard" clipboards if using xclip, see:
# http://unix.stackexchange.com/a/69134/89254
X11_write_clip <- function(content, object_type, breaks, eos, return_new, ...) {
if (has_xclip()) {
con <- pipe("xclip -i -sel p -f | xclip -i -sel c", "w")
} else if (has_xsel()) {
con <- pipe("xsel --clipboard --input", "w")
} else {
notify_no_cb()
}
.dots <- list(...)
write_nix(content, object_type, breaks, eos, return_new, con, .dots)
}
# Check object type to determine if it will be handled as a simple table or as a
# character vector
render_object <- function(content, object_type, breaks, .dots) {
if (object_type == "auto")
object_type <- eval_object(content)
switch(object_type,
"table" = table_str(content, breaks, .dots),
"character" = flat_str(content, breaks))
}
eval_object <- function(content) {
ifelse(is.data.frame(content) | is.matrix(content), "table", "character")
}
# If object is a table, default to a multiline string with tab separators
table_str <- function(content, breaks, .dots) {
# Take the system-specific collapse out of the list
.dots$x <- content
.dots$sep <- .dots$sep
.dots$quote <- ifelse(is.null(.dots$quote), FALSE, .dots$quote)
.dots$na <- ifelse(is.null(.dots$na), "", .dots$na)
.dots$col.names <- ifelse(is.null(.dots$col.names), !is.null(colnames(content)), .dots$col.names)
# Check if dataframe rownames are anything different than the default numbered names
numbered_rownames <- all(rownames(content) == as.character(seq_along(rownames(content))))
.dots$row.names <- ifelse(is.null(.dots$row.names), ifelse(numbered_rownames, FALSE, !is.null(rownames(content))), .dots$row.names)
# Writing to and reading from a temp file is much faster than using capture.output
tbl_file <- tempfile()
.dots$file = tbl_file
do.call(utils::write.table, .dots)
read_tbl <- paste0(readLines(tbl_file), collapse = breaks)
unlink(tbl_file)
# If row.names = TRUE and col.names = TRUE, add additional sep character to
# the start of the table
if (.dots$row.names & .dots$col.names) {
read_tbl <- paste0(.dots$sep, read_tbl)
}
return(read_tbl)
}
# Helper function to flatten content into 1-tuple character vector (i.e. a
# string)
flat_str <- function(content, breaks) {
if (typeof(content) != "character") {
warning("Coercing content to character")
content <- as.character(content)
}
if (length(content) < 1) {
content <- ""
} else if (length(content) > 1) {
content <- paste0(content, collapse = breaks)
} else if (is.na(content)) {
content <- "NA"
}
return(content)
}
write_clip_tibble_with_header(airports)
names(tbl)
write_clip_tibble_with_header = function(tbl, ...){
object_type = "character"
breaks = NULL
eos = NULL
return_new = FALSE
envir_vars = Sys.getenv()
header_content = paste0(
"User: ",envir_vars["USERNAME"]," Timestamp: ",Sys.time(),
" Clipped From: ", rstudioapi::getSourceEditorContext()$path
)
line_tbl = tbl %>%
tidyr::unite(line,everything(),sep = "\t")
string_tbl = line_tbl %>%
dplyr::summarise(all_lines = paste(line,collapse = "\n")) %>%
pull(all_lines)
out_tbl = paste0(header_content,"\n\n",
paste(names(tbl),collapse = "\t"),"\n",
string_tbl)
sys.type <- Sys.info()["sysname"]
chosen_write_clip <- switch(sys.type, Darwin = osx_write_clip,
Windows = win_write_clip, X11_write_clip)
invisible(chosen_write_clip(out_tbl, object_type, breaks,
eos, return_new, ...))
}
write_clip_tibble_with_header(airports)
out_tbl = paste0(header_content,"\n\n",
{if(!is.null(desc)){paste0("Description: ",desc,"\n")}}
paste(names(tbl),collapse = "\t"),"\n",
string_tbl)
out_tbl = paste0(header_content,"\n\n",
{if(!is.null(desc)){paste0("Description: ",desc,"\n")}},
paste(names(tbl),collapse = "\t"),"\n",
string_tbl)
desc = NULL
out_tbl = paste0(header_content,"\n\n",
{if(!is.null(desc)){paste0("Description: ",desc,"\n")}},
paste(names(tbl),collapse = "\t"),"\n",
string_tbl)
write_clip_tibble_with_header = function(tbl, desc = NULL, ...){
object_type = "character"
breaks = NULL
eos = NULL
return_new = FALSE
envir_vars = Sys.getenv()
header_content = paste0(
"User: ",envir_vars["USERNAME"]," Timestamp: ",Sys.time(),
" Clipped From: ", rstudioapi::getSourceEditorContext()$path
)
line_tbl = tbl %>%
tidyr::unite(line,everything(),sep = "\t")
string_tbl = line_tbl %>%
dplyr::summarise(all_lines = paste(line,collapse = "\n")) %>%
pull(all_lines)
out_tbl = paste0(header_content,"\n\n",
{if(!is.null(desc)){paste0("Description: ",desc,"\n")}},
paste(names(tbl),collapse = "\t"),"\n",
string_tbl)
sys.type <- Sys.info()["sysname"]
chosen_write_clip <- switch(sys.type, Darwin = osx_write_clip,
Windows = win_write_clip, X11_write_clip)
invisible(chosen_write_clip(out_tbl, object_type, breaks,
eos, return_new, ...))
}
write_clip_tibble_with_header(airports, "Airports test")
write_clip_tibble_with_header = function(tbl, desc = NULL, ...){
object_type = "character"
breaks = NULL
eos = NULL
return_new = FALSE
envir_vars = Sys.getenv()
header_content = paste0(
"User: ",envir_vars["USERNAME"]," Timestamp: ",Sys.time(),
" Clipped From: ", rstudioapi::getSourceEditorContext()$path
)
line_tbl = tbl %>%
tidyr::unite(line,everything(),sep = "\t")
string_tbl = line_tbl %>%
dplyr::summarise(all_lines = paste(line,collapse = "\n")) %>%
pull(all_lines)
out_tbl = paste0(header_content,"\n",
{if(!is.null(desc)){paste0("Description: ",desc,"\n")}},
"\n",
paste(names(tbl),collapse = "\t"),"\n",
string_tbl)
sys.type <- Sys.info()["sysname"]
chosen_write_clip <- switch(sys.type, Darwin = osx_write_clip,
Windows = win_write_clip, X11_write_clip)
invisible(chosen_write_clip(out_tbl, object_type, breaks,
eos, return_new, ...))
}
write_clip_tibble_with_header(airports, "Airports test")
NaN
library(nntools)
use_mit_license()
library(nntools)
library(nntools)
pkgdown::init_site()
pkgdown::build_site()
usethis::use_pkgdown()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
library(nntools)
library(nntools)
line_tbl = tbl %>%
tidyr::unite(line,tidyselect::everything(),sep = "\t")
line_tbl = tbl %>%
tidyr::unite('line',tidyselect::everything(),sep = "\t")
line_tbl = tbl %>%
tidyr::unite(line,tidyselect::everything(),sep = "\t")
string_tbl = line_tbl %>%
dplyr::summarise(all_lines = paste(.data$line,collapse = "\n")) %>%
dplyr::pull(.data$all_lines)
